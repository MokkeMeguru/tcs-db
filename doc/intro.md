# Integrant + REPL + SQL (postgresql + next.jdbc + hikari-cp)
## 対象
- 逆ポーランド記法をある程度理解できる（したい）人
- Clojure を書いたことがある(書きたい)人
- Clojure で (API) サーバを書きたい人

## Integrant?
Integrant は Clojure アプリケーションの ライフサイクルを管理するための **フレームワーク** の一つです。
ライフサイクル、とはシステムの起動、停止、更新、再起動等といった機能を示していると考えて頂いて大丈夫だと思います。
ライフサイクルの有名な例としては、React のコンポーネントに関するライフサイクル を挙げることが出来ます。

React のコンポーネントのライフサイクルとは、例えば SPA (single page application) を開発した際、ページを読み込んだ際に特定の要素を読み込み、表示、更新、削除、する一連の流れを指します。

ライフサイクルを導入することで、インスタンスの効率的な管理が出来るためにアプリケーションパフォーマンスの向上が図れますし、インスタンスの構造を簡単に把握することが出来ます。

例えば不要になった配列を削除することで、メモリ使用量を抑えられる他、うっかりその配列を別の場所で呼び出してしまい、不自然な位置に表示されてしまうことが防げます。

Integrant に話を戻しましょう。

Integrant では このライフサイクルを専ら設定ファイル (resources/config.edn) に記述します。ここでどのインスタンスがどのインスタンスに依存しているのか、という情報を書きます。

```clojure:config.edn
{:env {}
 :sql {:e ig/ref env}
 :api-server {:s ig/ref :sql 
              :e ig/ref :env }}
```

これはPython の辞書構造のようにして読むことが出来ます。
例えば `:sql` は  `:e` キーで表される `env` というインスタンスから依存を受けていることを示しています。
`ig/ref env` とは integrant が管理している `env` というインスタンス (つまり一行上の `:env` です)  を指しています。

そして Clojure コードで 初期化、終了、更新、サスペンド などのインスタンスごとの振る舞いを記述していきます。

```clojure:env.clj
(defmethod ig/init-key ::env [_ _]
 (load-env))
```

例えばこれは初期化の振る舞いを記述する関数の例です。ちょこちょこ関数名に疑問符を浮かべる場合があると思いますが、これは後述されます。


## Integrant + REPL?

Clojure (ClojureScript) の見どころとして、Hot Loadingによる開発の高速化が挙げられます。これを完結に言えば、 **記述したコードの即時反映** です。例えば C++ や Java でサーバを構築するならば (普通は) ①コードを書いて②コンパイルして③実際にAPIを叩いてみて⑤①へ戻る というような動きになります。

しかし書いたコードが即時反映されるならばこのデバッグ速度はずっと早くなりますし、第一に開発者のストレスはぐっと減ります。

Clojure では REPL (read eval print loop) という仕組みが中心になってこの Hot Loading を実現しています。なおかつ実際に完成したプログラムを実行する際にはコンパイルされた Jar ファイル として実行するため、パフォーマンスを削らずに済むようになっています。

ここで重要になってくるのがライフサイクルで、書いたコードを依存関係を保ったまま実行するにはある程度のルールがあると便利です。

例えばデータベースにアクセスする関数とデータベースでの手続きを記述した関数を実装したとき、データベースにアクセスする関数が先に反映されてくれないと都合が悪い、ということがなんとなく想像できると思います。

するとライフサイクルを管理しながら書いたコードを反映できる機構が求められるわけです。それが Integrant + REPL になります。

## SQL?
サーバを立てるからには SQL がほとんどの場合で必要になります。
Clojureでは専ら hikari-cp を始めとしたネクションプール (Postgresql サーバなどへの効率的な接続口) ライブラリと next.jdbc のような (SQL の実行) ライブラリ、そして honey sql のような (SQL のDSL)ライブラリによって SQL 周りの処理が記述されます。

また Clojure では、デバッグの容易さなどから、 SQL の処理と Clojure 内部で書かれた関数の処理をできるだけ粗結合にしたく、SQL処理部分はフォルダを分けるなどして記述されていきます。
これによって開発をする場合にも、SQL周りを処理する部分、APIの外側を処理する部分、データのバリデーションをする部分、などに分離して開発を行うことが出来ます。

今回特に扱うのはこの SQL の部分の処理になります。
つまみとしては 、 `ragtime` というライブラリを用いたデータベースのマイグレーションを行います。
# Introduction to task-cabinet-server(-db)
## 環境変数の読み込み
環境変数を読み込むにはライブラリ `environ` を用いると便利です。
これは開発時・テスト時・本番時ごとに環境変数を切り替えることを容易にするライブラリです。
 
 TODO: 書き込むファイルと書式、Production 時の引数の与え方についての説明
## PostgreSQL サーバへの接続テスト

TODO: write

## Migration の書き込み

```shell
 mkdir -p resources/migrations
 ```

で migration 用のフォルダを作ります。

# Q&A
- rollback はできるの？

あとで実装します。
TODO ref. migrate.clj あたり

- Alter Table はできるの？

 `resources/migrations/<idx>-<table-name>.up/down.sql`  を作成してください。但し `<idx>` には最大の値を指定してください。

# develop-memo
chime で 1 時間ごとに user_token のチェック⇒削除

